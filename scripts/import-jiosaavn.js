/**
 * Import JioSaavn songs to HuggingFace Recommender Backend
 * 
 * Reads the CSV file generated by jiosaavn-fetcher.js and
 * uploads all songs to your recommendation vector database
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// Configuration
const RECOMMENDER_API = 'https://atharva025-saafy-music-recommender.hf.space/api/add-song';
const INPUT_FILE = path.join(__dirname, 'data', 'jiosaavn_songs.csv');
const BATCH_SIZE = 10; // Songs to upload per batch
const BATCH_DELAY = 2000; // Delay between batches (ms)
const REQUEST_TIMEOUT = 10000; // 10 seconds

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Parse CSV file
function parseCSV(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n').slice(1); // Skip header

    const songs = [];
    for (const line of lines) {
        if (!line.trim()) continue;

        // Parse CSV with quoted fields
        const matches = line.match(/"([^"]*)"/g);
        if (!matches || matches.length < 5) continue;

        const [songId, songName, artist, album, year] = matches.map(m => m.replace(/"/g, '').trim());

        if (songId && songName) {
            songs.push({ songId, songName, artist, album, year: parseInt(year) || 2024 });
        }
    }

    return songs;
}

// Upload song to recommender
async function uploadSong(song) {
    try {
        const response = await axios.post(
            RECOMMENDER_API,
            null, // No body
            {
                params: {
                    song_id: song.songId,
                    song_name: song.songName
                },
                timeout: REQUEST_TIMEOUT,
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );

        if (response.status === 200) {
            return { success: true, song };
        } else {
            return { success: false, song, error: `Status ${response.status}` };
        }
    } catch (error) {
        return {
            success: false,
            song,
            error: error.response?.data?.detail || error.message
        };
    }
}

// Main import function
async function importSongs() {
    console.log('üì§ JioSaavn to Recommender Importer');
    console.log('‚ïê'.repeat(60));

    // Check if file exists
    if (!fs.existsSync(INPUT_FILE)) {
        console.error(`‚ùå File not found: ${INPUT_FILE}`);
        console.error('\nüí° Run this first: npm run fetch-jiosaavn');
        process.exit(1);
    }

    // Parse CSV
    console.log(`\nüìñ Reading: ${INPUT_FILE}`);
    const songs = parseCSV(INPUT_FILE);
    console.log(`‚úÖ Found ${songs.length} songs to import\n`);

    if (songs.length === 0) {
        console.error('‚ùå No songs found in CSV file');
        process.exit(1);
    }

    // Statistics
    let uploaded = 0;
    let failed = 0;
    let skipped = 0;
    const errors = [];

    // Process in batches
    const totalBatches = Math.ceil(songs.length / BATCH_SIZE);
    console.log(`üîÑ Processing ${totalBatches} batches of ${BATCH_SIZE} songs...\n`);

    for (let i = 0; i < songs.length; i += BATCH_SIZE) {
        const batch = songs.slice(i, i + BATCH_SIZE);
        const batchNum = Math.floor(i / BATCH_SIZE) + 1;

        console.log(`\nüì¶ Batch ${batchNum}/${totalBatches} (Songs ${i + 1}-${Math.min(i + BATCH_SIZE, songs.length)})`);
        console.log('‚îÄ'.repeat(60));

        // Upload batch concurrently
        const promises = batch.map(song => uploadSong(song));
        const results = await Promise.all(promises);

        // Process results
        for (const result of results) {
            if (result.success) {
                uploaded++;
                console.log(`  ‚úÖ ${result.song.songName} by ${result.song.artist}`);
            } else {
                if (result.error?.includes('already exists')) {
                    skipped++;
                    console.log(`  ‚è≠Ô∏è  ${result.song.songName} (already exists)`);
                } else {
                    failed++;
                    console.log(`  ‚ùå ${result.song.songName}: ${result.error}`);
                    errors.push({ song: result.song, error: result.error });
                }
            }
        }

        // Progress update
        const progress = ((i + batch.length) / songs.length * 100).toFixed(1);
        console.log(`\nüìä Progress: ${progress}% | ‚úÖ ${uploaded} uploaded | ‚è≠Ô∏è  ${skipped} skipped | ‚ùå ${failed} failed`);

        // Rate limiting between batches
        if (i + BATCH_SIZE < songs.length) {
            console.log(`‚è≥ Waiting ${BATCH_DELAY}ms before next batch...`);
            await sleep(BATCH_DELAY);
        }
    }

    // Final report
    console.log('\n' + '‚ïê'.repeat(60));
    console.log('‚úÖ Import Complete!');
    console.log('‚ïê'.repeat(60));
    console.log(`üìä Final Statistics:`);
    console.log(`   Total songs processed: ${songs.length}`);
    console.log(`   ‚úÖ Successfully uploaded: ${uploaded}`);
    console.log(`   ‚è≠Ô∏è  Already existed (skipped): ${skipped}`);
    console.log(`   ‚ùå Failed: ${failed}`);
    console.log(`   Success rate: ${((uploaded + skipped) / songs.length * 100).toFixed(1)}%`);
    console.log('‚ïê'.repeat(60));

    // Show errors if any
    if (errors.length > 0) {
        console.log('\n‚ö†Ô∏è  Errors encountered:');
        errors.slice(0, 10).forEach((e, i) => {
            console.log(`   ${i + 1}. ${e.song.songName}: ${e.error}`);
        });
        if (errors.length > 10) {
            console.log(`   ... and ${errors.length - 10} more errors`);
        }
    }

    console.log('\nüéâ Database population complete!');
}

// Run importer
console.log('üöÄ Starting import in 3 seconds...\n');
console.log('‚ö†Ô∏è  This will upload songs to your HuggingFace backend.');
console.log('   Press Ctrl+C to cancel.\n');

setTimeout(() => {
    importSongs().catch(error => {
        console.error('\n‚ùå Fatal error:', error.message);
        console.error(error.stack);
        process.exit(1);
    });
}, 3000);
